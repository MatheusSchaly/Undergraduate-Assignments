//! Copyright 2018 Matheus Henrique Schaly

#ifndef AVL_TREE_H
#define AVL_TREE_H

#include <stdexcept>
#include <algorithm>  // std::max
#include "array_list.h"


namespace structures {

//! AVLTree implementation
template<typename T>
class AVLTree {
public:
    //! Destructor
    ~AVLTree();

    //! Inserts an element
    void insert(const T& data);

    //! Removes an element
    void remove(const T& data);

    //! True if tree contains the data, false otherwise
    bool contains(const T& data) const;

    //! True is tree is empty, false otherwise
    bool empty() const;

    //! Tree's current size
    std::size_t size() const;

    //! Orders the elements as middle left right
    ArrayList<T> pre_order() const;

    //! Orders the elements as left middle right
    ArrayList<T> in_order() const;

    //! Orders the elements as left right middle
    ArrayList<T> post_order() const;

    //! Prints the tree
    void print_tree();

private:
    struct Node {
        T data;
        std::size_t height{0u};
        Node* left{nullptr};
        Node* right{nullptr};

        //! Constructor
        explicit Node(const T& data) {
            this -> data = data;
        }

        //! Inserts a node
        Node* insert(const T& data) {
            if (data < this -> data) {
                if (left == nullptr) {
                    left = new Node(data);
                } else {
                    left = left -> insert(data);
                }
            } else {
                if (right == nullptr) {
                    right = new Node(data);
                } else {
                    right = right -> insert(data);
                }
            }

            updateHeight();

            int bf = this -> bf();

            if (bf > 1) {  // Left is heavier, rot. right is needed
                if (this -> left -> bf() >= 0) {
                    return this -> simpleRight();
                } else {
                    return this -> doubleRight();
                }
            } else if (bf < -1) {  // Right is heavier, rot. left is needed
                if (this -> right -> bf() <= 0) {
                    return this -> simpleLeft();
                } else {
                    return this -> doubleLeft();
                }
            } else {
                return this;
            }
        }

        Node* remove(const T& data) {
            if ((data > this -> data) && (right != nullptr)) {
                right = right -> remove(data);
            } else if ((data < this -> data) && (left != nullptr)) {
                left = left -> remove(data);
            } else {
                if ((right != nullptr) && (left != nullptr)) {
                    this -> data = right -> find_minimum();
                    right = right -> remove(data);
                } else if (right != nullptr) {
                    this -> data = right -> data;
                    right = right -> remove(this -> data);
                } else if (left != nullptr) {
                    this -> data = left -> data;
                    left = left -> remove(this -> data);
                } else {
                    delete this;
                    return nullptr;
                }
            }

            updateHeight();

            int bf = this -> bf();

            if (bf > 1) {  // Left is heavier, rot. right is needed
                if (this -> left -> bf() >= 0) {
                    return this -> simpleRight();
                } else {
                    return this -> doubleRight();
                }
            } else if (bf < -1) {  // Right is heavier, rot. left is needed
                if (this -> right -> bf() <= 0) {
                    return this -> simpleLeft();
                } else {
                    return this -> doubleLeft();
                }
            } else {
                return this;
            }
        }

        T find_minimum() {
            if (left == nullptr) {
                return this -> data;
            } else {
                return left -> find_minimum();
            }
        }

        bool contains(const T& data) const {
            if (data == this -> data) {
                return true;
            } else {
                if ((data < this -> data) && (left != nullptr)) {
                    return left -> contains(data);
                } else if (right != nullptr) {
                    return right -> contains(data);
                } else {
                    return false;
                }
            }
        }

        //! Updates the node's height
        void updateHeight() {
            if ((left != nullptr) && (right != nullptr)) {
                height = std::max(left -> height, right -> height) + 1;
            } else if (left != nullptr) {
                height = left -> height + 1;
            } else if (right != nullptr) {
                height = right -> height + 1;
            } else {
                height = 0;
            }
        }

        //! Left rotation (RR rotation)
        Node* simpleLeft() {
            Node *temp = right;
            right = right -> left;
            temp -> left = this;
            temp -> left -> updateHeight();
            if (temp -> right != nullptr) {
                temp -> right -> updateHeight();
            }
            temp -> left -> updateHeight();
            temp -> updateHeight();
            return temp;
        }

        //! Right rotation (LL rotation)
        Node* simpleRight() {
            Node *temp = left;
            left = left -> right;
            temp -> right = this;
            if (temp -> left != nullptr) {
                temp -> left -> updateHeight();
            }
            temp -> right -> updateHeight();
            temp -> updateHeight();
            return temp;
        }

        //! Big left rotation (RL rotation)
        Node* doubleLeft() {
            right = right -> simpleRight();
            return this -> simpleLeft();
        }

        //! Big right rotation (LR rotation)
        Node* doubleRight() {
            left = left -> simpleLeft();
            return this -> simpleRight();
        }

        void pre_order(ArrayList<T>& v) const {
            v.push_back(data);
            if (left != nullptr) {
                left -> pre_order(v);
            }
            if (right != nullptr) {
                right -> pre_order(v);
            }
        }

        void in_order(ArrayList<T>& v) const {
            if (left != nullptr) {
                left -> in_order(v);
            }
            v.push_back(data);
            if (right != nullptr) {
                right -> in_order(v);
            }
        }

        void post_order(ArrayList<T>& v) const {
            if (left != nullptr) {
                left -> post_order(v);
            }
            if (right != nullptr) {
                right -> post_order(v);
            }
            v.push_back(data);
        }

        int bf() {
            if ((left != nullptr) && (right != nullptr)) {
                return (left -> height + 1) - (right -> height + 1);
            } else if (left != nullptr) {
                return left -> height + 1;
            } else if (right != nullptr) {
                return -(right -> height + 1);
            } else {
                return 0;
            }
        }

        void print_tree() {
            std::cout << data << "  ";
            if (left != nullptr) {
                left -> print_tree();
            }
            if (right != nullptr) {
                right -> print_tree();
            }
        }
    };

    Node* root{nullptr};
    std::size_t size_{0u};
};

}  // namespace structures

//! Destructor
template <typename T>
structures::AVLTree<T>::~AVLTree() {
    delete root;
    size_ = 0u;
}

//! Inserts an element
template <typename T>
void structures::AVLTree<T>::insert(const T& data) {
    if (empty()) {
        root = new Node(data);
        size_++;
    } else if (!contains(data)) {
        root = root -> insert(data);
        size_++;
    }
    // print_tree();
}

//! Removes an element
template <typename T>
void structures::AVLTree<T>::remove(const T& data) {
    std::cout << "Data: " << data << std::endl;
    print_tree();
    if (empty() || !contains(data)) {
        return;
    } else {
        root = root -> remove(data);
        size_--;
    }
    print_tree();
}


//! True if tree contains the data, false otherwise
template <typename T>
bool structures::AVLTree<T>::contains(const T& data) const {
    if (empty()) {
        return false;
    } else {
        return root -> contains(data);
    }
}

//! True is tree is empty, false otherwise
template <typename T>
bool structures::AVLTree<T>::empty() const {
    return size_ == 0;
}

//! Tree's current size
template <typename T>
std::size_t structures::AVLTree<T>::size() const {
    return size_;
}

//! Orders the elements as middle left right
template <typename T>
structures::ArrayList<T> structures::AVLTree<T>::pre_order() const {
    structures::ArrayList<T> v{};
    if (!empty()) {
        root -> pre_order(v);
    }
    return v;
}

//! Orders the elements as left middle right
template <typename T>
structures::ArrayList<T> structures::AVLTree<T>::in_order() const {
    structures::ArrayList<T> v{};
    if (!empty()) {
        root -> in_order(v);
    }
    return v;
}

//! Orders the elements as left right middle
template <typename T>
structures::ArrayList<T> structures::AVLTree<T>::post_order() const {
    structures::ArrayList<T> v{};
    if (!empty()) {
        root -> post_order(v);
    }
    return v;
}

template <typename T>
void structures::AVLTree<T>::print_tree() {
    std::cout << "Tree size: " << size_ << std::endl;
    if (!empty()) {
        root -> print_tree();
    }
    std::cout << std::endl << std::endl;;
}

#endif